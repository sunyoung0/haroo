# 회원 가입

## 생성자 매개변수 불일치

- 객체를 생성할 때 전달하는 **인자(Argument)**의 순서와 클래스에 정의된 **생성자 매개변수(Parameter)**의 순서가 달라서 DB에 엉뚱한 값이 저장됨

```java
// Service - 객체 생성
// 순서: 1.email, 2.password, 3.nickname
User user = new User(dto.email(), passwordEncoder.encode(dto.password()), dto.nickname());

// Entity - 생성자 정의
// 순서: 1.password, 2.nickname, 3.email
public User(String password, String nickname, String email) {
  this.password = password;
  this.nickname = nickname;
  this.email = email;
}
```

- 원인 : 매개변수 이름이 같아도 순서가 다르면 잘못된 값이 할당됨.
  현재같이 전부 동일한 타입일 경우 컴파일 에러가 발생하지 않아서 런타임 에러를 찾기 어려움
  자바는 생성자 호출 시 **타입과 위치(순서)**를 기준으로 값을 바인딩함

- 해결 방법

1. 생성자에 파라미터 순서 맞춰주기 (파라미터가 2개 이하일 때 권장)
2. Builder 패턴 사용

- 각 필드에 어떤 값이 들어가는지 명확히 명시하므로 순서가 바뀌어도 안전함
- 값이 추가 되어도 .phone(dto.phone())만 해주면 됨

- entity에 @Builder, @AllArgsConstructor, @NoArgsConstructor(access = AccessLevel.PROTECTED) 붙여줌
- service에 builder패턴으로 작성

```java
User user = User.builder()
    .email(dto.email())
    .password(passwordEncoder.encode(dto.password()))
    .nickname(dto.nickname())
    .build();
```

-  참고
JPA 엔티티와 빌더 패턴 사용 시 주의점

@NoArgsConstructor(access = AccessLevel.PROTECTED): JPA가 DB 데이터를 객체로 만들 때(리플렉션) 기본 생성자가 필수임. 다만, 무분별한 객체 생성을 막기 위해 protected로 제한함.

@AllArgsConstructor: @Builder는 내부적으로 모든 필드를 인자로 받는 생성자를 사용함. 기본 생성자와 함께 사용할 때는 이를 명시적으로 선언해줘야 충돌이 없음.

결론: 엔티티에는 @Builder, @NoArgsConstructor(access = AccessLevel.PROTECTED), @AllArgsConstructor를 세트로 붙이는 것이 표준 관례임.
