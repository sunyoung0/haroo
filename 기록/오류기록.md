# 회원 가입

## 생성자 매개변수 불일치

- 객체를 생성할 때 전달하는 **인자(Argument)**의 순서와 클래스에 정의된 **생성자 매개변수(Parameter)**의 순서가 달라서 DB에 엉뚱한 값이 저장됨

```java
// Service - 객체 생성
// 순서: 1.email, 2.password, 3.nickname
User user = new User(dto.email(), passwordEncoder.encode(dto.password()), dto.nickname());

// Entity - 생성자 정의
// 순서: 1.password, 2.nickname, 3.email
public User(String password, String nickname, String email) {
  this.password = password;
  this.nickname = nickname;
  this.email = email;
}
```

- 원인 : 매개변수 이름이 같아도 순서가 다르면 잘못된 값이 할당됨.
  현재같이 전부 동일한 타입일 경우 컴파일 에러가 발생하지 않아서 런타임 에러를 찾기 어려움
  자바는 생성자 호출 시 **타입과 위치(순서)**를 기준으로 값을 바인딩함

- 해결 방법

1. 생성자에 파라미터 순서 맞춰주기 (파라미터가 2개 이하일 때 권장)
2. Builder 패턴 사용

- 각 필드에 어떤 값이 들어가는지 명확히 명시하므로 순서가 바뀌어도 안전함
- 값이 추가 되어도 .phone(dto.phone())만 해주면 됨

- entity에 @Builder, @AllArgsConstructor, @NoArgsConstructor(access = AccessLevel.PROTECTED) 붙여줌
- service에 builder패턴으로 작성

```java
User user = User.builder()
    .email(dto.email())
    .password(passwordEncoder.encode(dto.password()))
    .nickname(dto.nickname())
    .build();
```

- 참고
  JPA 엔티티와 빌더 패턴 사용 시 주의점

@NoArgsConstructor(access = AccessLevel.PROTECTED): JPA가 DB 데이터를 객체로 만들 때(리플렉션) 기본 생성자가 필수임. 다만, 무분별한 객체 생성을 막기 위해 protected로 제한함.

@AllArgsConstructor: @Builder는 내부적으로 모든 필드를 인자로 받는 생성자를 사용함. 기본 생성자와 함께 사용할 때는 이를 명시적으로 선언해줘야 충돌이 없음.

결론: 엔티티에는 @Builder, @NoArgsConstructor(access = AccessLevel.PROTECTED), @AllArgsConstructor를 세트로 붙이는 것이 표준 관례임.

# 로그인

## 예외처리를 지정해줬지만 지정 문구가 뜨지 않고 403 Forbidden이 뜸

```java
// JwtService.java
public boolean validateToken(String token) {
    try {
        Jwts.parser().verifyWith(SIGNINGKEY).build().parseSignedClaims(token);
        return true;
    } catch (Exception e) {
        return false; // <--- 여기서 예외를 먹어버리고 그냥 false를 던짐!
    }
}
```

- 동작 과정: 토큰이 틀리면 validateToken이 예외를 던지는 게 아니라, 그냥 false를 리턴

- JwtFilter의 if(jwtService.validateToken(token)) 조건문이 false가 되어 if 블록을 통과하지 못함

결과: catch 문으로 가지 않고 그냥 filterChain.doFilter()로 넘어가 버립니다. 인증 정보가 없으니 스프링 시큐리티가 `403 Forbidden!` 을 띄움

- JwtFilter에서 에러를 잡으려면, JwtService는 예외를 숨기지 말고 밖으로 던져줘야(throw) 함
```java
// boolean 리턴 대신, 실패하면 예외가 터지도록 수정
public boolean validateToken(String token) {
    Jwts.parser()
        .verifyWith(SIGNINGKEY)
        .build()
        .parseSignedClaims(token);
    return true;
}
```