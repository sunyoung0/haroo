# tailwind
- 최신 버전은 적용이 잘 안될 수도 있음
- 그래서 tailwindcss@3 으로 @3 붙여서 버전을 다운그레이드 해줘야함.
```bash
npm install -D tailwindcss@3 postcss autoprefixer
npx tailwindcss init -p
```
- 그리고 tailwind.config.js, postcss.config.js 이 두 파일이 생성 됐는 지 확인해야함.

- tailwind.config.js 수정
```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

- 마지막으로 globals.css 또는 index.css 제일 상단에 하단 3줄 추가
```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

# 유효성 검사
- dto에서 유효성 검사를 하기 위해선 의존성 추가해줘야함
```gradle
implementation 'org.springframework.boot:spring-boot-starter-validation'
```

- dto 단계에서 유효성 검사를 수행하면 서비스 로직으로 잘못된 값이 들어오는 것을 차단 할 수 있음
- message 값은 그대로 에러 응답 메시지로 활용됨

- 예시
```java
@NotBlank(message = "이메일은 필수 입력 값입니다.")
@Email(message = "이메일 형식이 올바르지 않습니다.")
String email
```

- 유효성 검사를 적용 시켜둔 dto를 @RequestBody로 받는 곳에 @Valid 어노테이션을 붙여줘야함. 필수로 붙여줘야 MethodArgumentNotValidException이 작동함.
- 유효성 검사는 컨트롤러 진입 시점에서 실행됨

# 예외 처리
1. 커스텀 예외 처리
- 이메일 중복, 닉네임 중복과 같은 비즈니스 예외
- @ResponseStatus는 직접 만든 커스텀 예외 클래스에만 붙일 수 있음, 해당 예외 발생 시 자동으로 상태 코드 매핑
- 서비스는 에러를 처리하지 않고 던지기만 함
```java
@ResponseStatus(HttpStatus.CONFLICT)
public class EmailExistsException extends RuntimeException {
    public EmailExistsException(String message) {
        super(message);
    }
}

// 적용 예시
if (userRepository.existsByEmail(dto.email())) {
    throw new EmailExistsException("이미 존재하는 이메일입니다.");
}
```

2. GlobalExceptionHandler (전역 예외 처리)
- 모든 컨트롤러에서 빌생하는 예외를 감시하고 한곳에서 모아서 일관된 응답 규격(JSON)으로 변환

- 핵심 역할
  - 일관성: 모든 에러 응답 형식을 ErrorResponseRecord로 통일
  - 분리: 서비스 로직은 에러를 던지기만(throw) 하고, 처리는 핸들러가 담당
  - 디버깅: 에러 발생 시간, 상태 코드, 메시지, 발생 경로(URI)를 한눈에 파악

- @RestControllerAdvice : 이 어노테이션이 붙은 클래스는 모든 컨트롤러에서 발생하는 예외를 감시함, 예외가 발생하면 해당 클래스 내의 메소드가 호출됨

- ErrorResponseRecord를 만들어 공통 에러 양식 설정
```java
public record ErrorResponseRecord(
  LocalDateTime timestamp,
  int status,
  String error,
  String message,
  String path
) {}
```

- WebRequest :
  - request.getDescription(false)를 사용하면 에러가 발생한 API 경로(URI)를 자동으로 가져올 수 있음
  - request.getDescription(true)인 경우 client 정보가 붙어서 나옴

