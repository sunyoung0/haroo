# 일기 작성 시 임시 저장 기능

## "마지막 타이핑 후 2~3초간 입력이 없을 때" 저장하는 디바운싱(Debouncing) 기술 사용

- diaryId가 null이면? -> isTemp = true로 새로 생성(save).
- diaryId가 있으면? -> 해당 ID의 글을 찾아 내용만 수정(update).

- diary Entity에 임시 저장 컬럼 추가

- 첫 작성 시 diaryId가 없음
  -> 그래서 자동 저장 로직은 다음처럼 진행됨

  1. 첫번째 저장 (입력 후 멈춤) : 프론트엔드가 diaryId: null과 함께 내용을 보냄

  백엔드는 isTemp: true로 데이터를 Insert하고, 생성된 diaryId: 101을 프론트엔드에 응답으로 돌려줌

  2. 두 번째 저장 (프론트엔드가 ID를 받은 후):
     프론트엔드는 방금 받은 101이라는 ID를 기억해둠
     -> 다음 자동 저장 때는 diaryId: 101과 수정된 내용을 보냄
     -> 백엔드는 ID가 있으니 새로 만들지 않고 Update만 함

- 결과적으로 사용자는 모르지만, 서버에서는 첫 자동 저장 때 이미 "임시 저장 상태의 글"이 하나 생성되는 것.

## 디바운싱(Debouncing)이란?

디바운싱은 **"연이어 호출되는 함수들 중 마지막(또는 처음)만 실행"**하는 기술

- 그냥 15초 주기: 사용자가 미친 듯이 타자를 치고 있어도 15초마다 무조건 서버에 요청을 보냄.

- 디바운싱: 사용자가 타자를 치는 동안에는 기다렸다가, 타자를 멈추고 2초가 지나면 그때 딱 한 번 저장함.

- 프론트엔드(React, Vue 등)에서 lodash 같은 라이브러리를 쓰면 됨

### 코드 작성

- 임시 저장 내용을 저장할 dto 생성 첫 작성 시 diaryId는 null

```java
public record DiaryTempSaveRequest(
    Long diaryId,      // 첫 저장 시 null
    Long groupId,
    String title,
    String content,
    FeelingType feelingType
) {}
```

- service 에서는 diaryId가 있으면 수정(update)을 하고 diaryId가 없으면 새로 생성(insert)하는 로직 작성

- 장점 : 중복 방지 - 사용자가 10분 동안 글을 써도 서버에는 딱 하나의 행(Row)만 생기고 내용만 계속 업데이트됨

- 최종 저장 시: 나중에 사용자가 진짜 '등록' 버튼을 누르면, 백엔드에서는 해당 ID의 isTemp만 false로 바꿔주면 끝

- 기존 일기 저장 로직에 임시 저장된 글이 있다면 정식 등록으로 전환하는 로직 추가해줌 (isTemp = false로 변경해줌)

- 그리고 일기 리스트를 조회하는 부분에 isTemp = false인 것들만 가져오는 조건을 추가해야함
  - 조건을 걸어주지 않으면 쓰다만 임시 저장된 글들도 다 리스트에 나오기 때문