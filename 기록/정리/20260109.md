# 알람 기능

## SSE(Server-Sent Events) 기반 실시간 알림 시스템

- 알림 엔티티 설계 : 알림은 "누가, 무엇 때문에, 어떤 데이터를 확인해야 하는가"를 담아야 함

- SSE는 클라이언트가 서버에 한 번 연결(Handshake)을 맺으면, 서버가 일방적으로 데이터를 밀어주는 방식

- 알림 전송 프로세스

  - SSE 연결: 클라이언트가 GET /api/notifications/subscribe 요청. 서버는 SseEmitter(클라이언트와의 실시간 연결 객체) 객체를 생성해 메모리에 저장.

  - 이벤트 발생: 어떤 유저가 댓글 작성 완료.

  - 데이터 저장: Notification 엔티티를 DB에 저장 (나중에 로그인했을 때 확인용).

  - 실시간 전송: SseEmitter 저장소에서 일기 작성자의 ID를 찾아 실시간 데이터 전송.

- 구현 시 주의할 점

  - SseEmitter 만료 시간: SSE는 연결 시간이 제한되어 있음. 보통 30분~1시간 정도로 설정하며, 만료 시 클라이언트가 재연결(Reconnection)을 시도하도록 프론트엔드 처리가 필요

  - 메모리 관리: SseEmitter는 서버 메모리에 저장. 서버가 여러 대(Scale-out)라면 Redis의 Pub/Sub을 활용해야 하지만, 단일 서버 단계라면 ConcurrentHashMap을 사용해 관리하는 것으로 충분

  - 더미 데이터 전송: 연결 직후 아무 데이터도 보내지 않으면 503 에러가 발생할 수 있음. 연결 성공 시 "Event Stream Created" 같은 더미 데이터를 첫 번째로 전송하는 것이 관례.

## SSE 기능을 구현하기 위해 가장 중요한 것은 SseEmitter를 관리하는 저장소와 알림을 생성하고 전송하는 서비스를 분리하는 것

1. EmitterRepository (연결 관리) 생성

- 먼저 서버 메모리에 클라이언트와의 연결 객체(SseEmitter)를 보관할 저장소가 필요함

2. NotificationService (비즈니스 로직)

- 알림을 DB에 저장하고, 현재 접속 중인 유저에게 실시간으로 데이터를 쏴주는 역할

3. NotificationController (엔드포인트)
   클라이언트(프론트엔드)에서 SSE를 구독하기 위한 API

4. 실제 사용 예시 (댓글 서비스 연동)
   이제 댓글이 작성될 때 알림 서비스의 send() 메서드를 호출하기만 하면 됨

- 구현 시 참고할 핵심 포인트
  Media Type: SSE 통신은 반드시 text/event-stream 타입을 사용해야 한다.

보안: 실제 서비스에서는 /subscribe 시 userId를 경로 변수로 받기보다, 시큐리티 컨텍스트(@AuthenticationPrincipal)에서 현재 로그인한 유저 정보를 가져오는 것이 안전.

트랜잭션: send() 로직에서 DB 저장은 성공했는데 SSE 전송이 실패할 경우를 대비해 예외 처리를 꼼꼼히 해주어야 함.

- EmitterRepository 와 NotificationRepository의 차이
- NotificationRepository (JPA)
  - 저장 위치 :  MySQL (Disk)
  - 저장 데이터 : 알림 내역 (누가, 언제, 어떤 내용 등)
  - 생존 기간 : 영구적 (삭제 전까지)
  - 주요 용도 : 나중에 다시 보기, 읽음 처리, 히스토리 관리

- EmitterRepository (In-Memory)
  - 저장 위치 : 서버 메모리 (RAM)
  - 저장 데이터 : 클라이언트와의 실시간 연결 객체(SseEmitter)
  - 생존 기간 : 일시적 (브라우저 종료나 연결 만료 시 삭제)
  - 주요 용도 : 지금 당장 실시간으로 알림을 쏴주기 위함

