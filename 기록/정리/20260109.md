# 알람 기능

## SSE(Server-Sent Events) 기반 실시간 알림 시스템

- 알림 엔티티 설계 : 알림은 "누가, 무엇 때문에, 어떤 데이터를 확인해야 하는가"를 담아야 함

- SSE는 클라이언트가 서버에 한 번 연결(Handshake)을 맺으면, 서버가 일방적으로 데이터를 밀어주는 방식

- 알림 전송 프로세스

  - SSE 연결: 클라이언트가 GET /api/notifications/subscribe 요청. 서버는 SseEmitter(클라이언트와의 실시간 연결 객체) 객체를 생성해 메모리에 저장.

  - 이벤트 발생: 어떤 유저가 댓글 작성 완료.

  - 데이터 저장: Notification 엔티티를 DB에 저장 (나중에 로그인했을 때 확인용).

  - 실시간 전송: SseEmitter 저장소에서 일기 작성자의 ID를 찾아 실시간 데이터 전송.

- 구현 시 주의할 점

  - SseEmitter 만료 시간: SSE는 연결 시간이 제한되어 있음. 보통 30분~1시간 정도로 설정하며, 만료 시 클라이언트가 재연결(Reconnection)을 시도하도록 프론트엔드 처리가 필요

  - 메모리 관리: SseEmitter는 서버 메모리에 저장. 서버가 여러 대(Scale-out)라면 Redis의 Pub/Sub을 활용해야 하지만, 단일 서버 단계라면 ConcurrentHashMap을 사용해 관리하는 것으로 충분

  - 더미 데이터 전송: 연결 직후 아무 데이터도 보내지 않으면 503 에러가 발생할 수 있음. 연결 성공 시 "Event Stream Created" 같은 더미 데이터를 첫 번째로 전송하는 것이 관례.

## SSE 기능을 구현하기 위해 가장 중요한 것은 SseEmitter를 관리하는 저장소와 알림을 생성하고 전송하는 서비스를 분리하는 것

1. EmitterRepository (연결 관리) 생성

- 먼저 서버 메모리에 클라이언트와의 연결 객체(SseEmitter)를 보관할 저장소가 필요함

2. NotificationService (비즈니스 로직)

- 알림을 DB에 저장하고, 현재 접속 중인 유저에게 실시간으로 데이터를 쏴주는 역할

3. NotificationController (엔드포인트)
   클라이언트(프론트엔드)에서 SSE를 구독하기 위한 API

4. 실제 사용 예시 (댓글 서비스 연동)
   이제 댓글이 작성될 때 알림 서비스의 send() 메서드를 호출하기만 하면 됨

- 구현 시 참고할 핵심 포인트
  Media Type: SSE 통신은 반드시 text/event-stream 타입을 사용해야 한다.

보안: 실제 서비스에서는 /subscribe 시 userId를 경로 변수로 받기보다, 시큐리티 컨텍스트(@AuthenticationPrincipal)에서 현재 로그인한 유저 정보를 가져오는 것이 안전.

트랜잭션: send() 로직에서 DB 저장은 성공했는데 SSE 전송이 실패할 경우를 대비해 예외 처리를 꼼꼼히 해주어야 함.

- EmitterRepository 와 NotificationRepository의 차이
- NotificationRepository (JPA)
  - 저장 위치 :  MySQL (Disk)
  - 저장 데이터 : 알림 내역 (누가, 언제, 어떤 내용 등)
  - 생존 기간 : 영구적 (삭제 전까지)
  - 주요 용도 : 나중에 다시 보기, 읽음 처리, 히스토리 관리

- EmitterRepository (In-Memory)
  - 저장 위치 : 서버 메모리 (RAM)
  - 저장 데이터 : 클라이언트와의 실시간 연결 객체(SseEmitter)
  - 생존 기간 : 일시적 (브라우저 종료나 연결 만료 시 삭제)
  - 주요 용도 : 지금 당장 실시간으로 알림을 쏴주기 위함

### . Dirty Checking (더티 체킹)이란?
Dirty Checking은 JPA 라이브러리가 제공하는 아주 편리한 기능입니다. 단어 그대로 **"상태 변경 검사"** 라는 뜻
@Transactional 안에서 객체 값만 바꾸면 업데이트가 자동으로 됨

- 기존 방식: 데이터를 수정하려면 update 쿼리를 직접 작성하거나, repository.save()를 명시적으로 호출해야 함

- 더티 체킹: 트랜잭션(@Transactional) 범위 안에서 DB에서 가져온 엔티티 객체의 값을 변경하면, 트랜잭션이 끝나는 시점에 JPA가 변경 사항을 감지해서 알아서 UPDATE 쿼리를 날려줘야함

- subscribe 메서드에 @Transactional이 걸려 있으면, unreadNotifications를 가져오는 동안 DB 커넥션을 점유하고 있게 됨. SSE는 연결을 오래 유지하는 특성이 있으므로, subscribe 메서드 자체에는 @Transactional을 붙이지 않는 것이 성능상 유리. (조회 로직이 필요하다면 별도의 readOnly = true가 걸린 서비스 메서드로 분리하는 것이 베스트)

## 오래된 알림 삭제 (스케쥴링)
- @EnableScheduling 메인 클래스에 달아줘야함
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class NotificationScheduler {

    private final NotificationRepository notificationRepository;

    // 매일 새벽 3시에 실행(cron 표현식: 초 분 시 일 월 요일), 30일이 지난 '읽은 알림' 삭제
    @Scheduled(cron = "0 0 3 * * *")
    public void deleteOldNotifications() {
        // 현재 시간 기준 30일 전 계산
        LocalDateTime retentionalPeriod = LocalDateTime.now().minusDays(30);

        log.info("알림 청소 스케쥴러 가동 : 30일 지난 읽은 알림 삭제");

        notificationRepository.deleteByCreatedAtBeforeAndIsReadTrue(retentionalPeriod);
        log.info("알림 청소 완료");
    }

}
```