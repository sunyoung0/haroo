## 예외 처리 및 유효성 검사

1. 유효성 검사
- 어노테이션 사용을 위해 의존성 추가
```gradle
implementation 'org.springframework.boot:spring-boot-starter-validation'
```

- dto에 유효성 검사 로직 추가
- dto 단계에서 유효성 검사를 수행하면 서비스 로직으로 잘못된 값이 들어오는 것을 차단 할 수 있음
- message 값은 그대로 에러 응답 메시지로 활용됨

```java
public record SignUpRequest(
    @NotBlank(message = "이메일은 필수 입력 값입니다.")
    @Email(message = "이메일 형식이 올바르지 않습니다.")
    String email,

    @NotBlank(message = "비밀번호는 필수 입력 값입니다.")
    @Size(min = 8, max = 20, message = "비밀번호는 8자 이상 20자 이하이어야 합니다.")
    @Pattern(
        regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,}$",
        message = "비밀번호는 영문 대소문자, 숫자, 특수문자를 최소 하나씩 포함해야 합니다."
    )
    String password,

    @NotBlank(message = "닉네임은 필수 입력 값입니다.")
    String nickname
) {}
```

- 유효성 검사를 적용 시켜둔 dto를 @RequestBody로 받는 곳에 @Valid 어노테이션을 붙여줘야함. 필수로 붙여줘야 MethodArgumentNotValidException이 작동함.
- 유효성 검사는 컨트롤러 진입 시점에서 실행됨

```java
@PostMapping("/signUp")
public ResponseEntity<User> signUp(@Valid @RequestBody SignUpRequest dto) {
    return userService.signUp(dto);
}
```

2. 커스텀 예외 처리

- 이메일 중복, 닉네임 중복과 같은 비즈니스 예외
- @ResponseStatus는 직접 만든 커스텀 예외 클래스에만 붙일 수 있음, 해당 예외 발생 시 자동으로 상태 코드 매핑
- 서비스는 에러를 처리하지 않고 던지기만 함

```java
@ResponseStatus(HttpStatus.CONFLICT)
public class EmailExistsException extends RuntimeException {
    public EmailExistsException(String message) {
        super(message);
    }
}

// 적용 예시
if (userRepository.existsByEmail(dto.email())) {
    throw new EmailExistsException("이미 존재하는 이메일입니다.");
}
```

3. GlobalExceptionHandler (전역 예외 처리)

- 모든 컨트롤러에서 방생하는 예외를 감시하고 한곳에서 모아서 일관된 응답 규격(JSON)으로 변환

- 핵심 역할

  - 일관성: 모든 에러 응답 형식을 ErrorResponseRecord로 통일.
  - 분리: 서비스 로직은 에러를 던지기만(throw) 하고, 처리는 핸들러가 담당.
  - 디버깅: 에러 발생 시간, 상태 코드, 메시지, 발생 경로(URI)를 한눈에 파악.

- @RestControllerAdvice : 이 어노테이션이 붙은 클래스는 모든 컨트롤러에서 발생하는 예외를 감시함, 예외가 발생하면 해당 클래스 내의 메소드가 호출됨

- ErrorResponseRecord를 만들어 공통 에러 양식 설정
```java
public record ErrorResponseRecord(
  LocalDateTime timestamp,
  int status,
  String error,
  String message,
  String path
) {}
```

- WebRequest :
  - request.getDescription(false)를 사용하면 에러가 발생한 API 경로(URI)를 자동으로 가져올 수 있음
  - request.getDescription(true)인 경우 client 정보가 붙어서 나옴


```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 1. DTO 유효성 검사 실패 (400 Bad Request)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponseRecord> handleValidation(MethodArgumentNotValidException ex, WebRequest request) {
        // getBindingResult()를 통해 DTO에 적은 message만 뽑아냄
        String msg = ex.getBindingResult().getAllErrors().get(0).getDefaultMessage();
        return createResponse(HttpStatus.BAD_REQUEST, "Validation Failed", msg, request);
    }

    // 2. 비즈니스 예외 (409 Conflict)
    @ExceptionHandler({EmailExistsException.class, NicknameExistsException.class})
    public ResponseEntity<ErrorResponseRecord> handleConflict(RuntimeException ex, WebRequest request) {
        return createResponse(HttpStatus.CONFLICT, "Already Exists", ex.getMessage(), request);
    }

    // 공통 응답 생성 로직
    private ResponseEntity<ErrorResponseRecord> createResponse(HttpStatus status, String error, String msg, WebRequest request) {
        ErrorResponseRecord res = new ErrorResponseRecord(
            LocalDateTime.now(), status.value(), error, msg,
            request.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(res, status);
    }
}
```
- 나중에 jwt 까지 끝낸 다음에 **createResponse** 사용해서 리팩토링 하기

- 적용 예시
  ![alt text](image.png)