# 엔티티 수정

# 유저 정보 조회

- 유저 정보안에 그룹 정보 리스트를 담은 DTO 생성

```java
// 그룹 간략 정보를 담을 DTO
public record GroupSummaryResponse(
    Long groupId,
    String title,
    GroupType type,
    MemberRole role // 해당 그룹에서 나의 역할 (주인인지 멤버인지)
) {}

// 최종 유저 정보 DTO
public record UserWithGroupsResponse(
    Long id,
    String email,
    String nickname,
    String profileImage,
    List<GroupSummaryResponse> groups
) {}
```

- repository에 조회 메서드 추가

- JOIN FETCH: 단순히 findAllByUser를 하면 그룹 이름을 알기 위해 그룹 테이블을 계속 조회하는 N+1 문제가 발생할 수 있음. JOIN FETCH를 써서 한 번의 쿼리로 그룹 정보까지 싹 긁어오는 게 성능상 훨씬 유리

JOIN FETCH를 쓰면 JPA는 SQL을 만들 때 아예 INNER JOIN을 사용해서 한꺼번에 모든 데이터를 가져옴
단 1번의 쿼리로 DiaryMember와 연관된 DiaryGroup 데이터까지 모두 실제 객체로 채워져서 나옴

```java
public interface DiaryMemberRepository extends JpaRepository<DiaryMember, Long> {
    // 특정 유저가 속한 모든 멤버 관계 정보를 가져옴 (그룹 정보까지 Fetch Join하면 성능에 좋음)
    @Query("SELECT m FROM DiaryMember m JOIN FETCH m.diaryGroup WHERE m.user = :user")
    List<DiaryMember> findAllByUserWithGroup(User user);
}
```

- service에 로직 추가 : 해당 유저의 그룹 참여 목록을 가져와 DTO로 변환
  - map 사용

```java
@Transactional(readOnly = true)
public UserWithGroupsResponse getUserWithGroups(String email) {
    // 1. 유저 조회
    User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다."));

    // 2. 유저가 속한 그룹 목록 조회
    List<DiaryMember> members = diaryMemberRepository.findAllByUserWithGroup(user);

    // 3. DTO 변환
    List<GroupSummaryResponse> groupResponses = members.stream()
            .map(m -> new GroupSummaryResponse(
                    m.getDiaryGroup().getId(),
                    m.getDiaryGroup().getTitle(),
                    m.getDiaryGroup().getType(),
                    m.getRole()
            ))
            .toList();

    return new UserWithGroupsResponse(
            user.getId(),
            user.getEmail(),
            user.getNickname(),
            user.getProfileImage(),
            groupResponses
    );
}
```

- controller에서 호출

```java
@GetMapping("/group")
public ResponseEntity<UserWithGroupsResponse> getMyInfoWithGroups(@AuthenticationPrincipal String email) {
    return ResponseEntity.ok(userService.getUserWithGroups(email));
}
```

# 개인/공유 다이어리 타입 생성

- dto 생성

```java
public record GroupCreateRequest(
    String title,
    String notice,
    GroupType type // PERSONAL, SHARED
) {}
```

- service 생성 : `@Transactional` 을 달아줘야 그룹 생성과 멤버 등록이 하나의 작업으로 묶여야 에러가 나도 데이터가 꼬이지 않음

```java
@Service
@RequiredArgsConstructor
public class DiaryGroupService {

    private final DiaryGroupRepository diaryGroupRepository;
    private final DiaryMemberRepository diaryMemberRepository;
    private final UserRepository userRepository;

    @Transactional
    public Long createGroup(String email, GroupCreateRequest dto) {
        // 1. 생성자 유저 찾기
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다."));

        // 2. 다이어리 그룹 엔티티 생성 및 저장
        DiaryGroup group = DiaryGroup.builder()
                .title(dto.title())
                .notice(dto.notice())
                .type(dto.type())
                .user(user)
                .build();

        DiaryGroup savedGroup = diaryGroupRepository.save(group);

        // 3. 생성자를 해당 그룹의 OWNER 멤버로 자동 등록
        DiaryMember member = DiaryMember.builder()
                .diaryGroup(savedGroup)
                .user(user)
                .role(MemberRole.OWNER) // 생성자는 관리자 권한
                .build();

        diaryMemberRepository.save(member);

        return savedGroup.getId();
    }
}
```

- controller에 로직 작성
```java
@PostMapping
public ResponseEntity<Long> createGroup(
    @AuthenticationPrincipal String email,
    @RequestBody GroupCreateRequest dto
) {
    Long groupId = diaryGroupService.createGroup(email, dto);
    return ResponseEntity.ok(groupId);
}
```