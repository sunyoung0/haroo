# 캘린더에서 날찌 조회 시 일기 리스트 조회 기능

- findFilteredDiaries()가 있지만 캘린더용 API가 따로 있는게 좋음 -> 데이터 낭비가 심하고 속도 저하
- Diary 객체 전체를 가져오기 때문에 본문 내용은 빼고 `일기가 존재하는 날짜 리스트`만 중복없이 가져오는게 좋음
```java
 // 2. 캘린더 점 찍기용 (날짜만 반환, DISTINCT로 중복 제거), 특정 그룹의 특정 월(Year-Month)에 일기가 있는 날짜들만 조회
    @Query("SELECT DISTINCT d.diaryDate FROM Diary d WHERE d.diaryGroup.id = :groupId " +
            "AND (:diaryDate IS NULL OR d.diaryDate LIKE CONCAT(:diaryDate, '%'))")
    List<String> findByEntryDatesByMonth(@Param("groupId") Long groupId, @Param("diaryDate") String diaryDate);

```
- :diaryDate IS NULL 처리를 통해 파라미터가 비어있을 때 해당 조건을 무시하도록 만드는 기법

# Base TimeEntity
- 단순히 필드에 LocalDateTime.now()를 넣는 것보다 좋음
  - 중복 제거 : 모든 엔티티에 생성 시간 코드를 넣을 필요 없이 상속만 받으면 끝남
  - 일관성 : 컬럼명이 통일되어 관리하기 쉬움
  - 자동화 : 수정 시간의 경우 알아서 시간을 갱신 해줌

- 시간 구현 방식,특징,추천 여부
  - LocalDateTime.now() : 직접 대입, 구현은 쉽지만, 매번 직접 코드를 짜야 하고 수정 시간 관리가 어려움
  - @PrePersist : 사용,별도 설정 없이 엔티티 내에서 해결 가능하나 중복 코드가 발생함
  - BaseTimeEntity + @CreatedDate : 가장 깔끔하고 실무에서 99% 사용하는 표준 방식
```java
@Getter
@MappedSuperclass // JPA Entity 들이 이 클래스를 상속받을 경우 필드들도 컬럼으로 인식하게 함
@EntityListeners(AuditingEntityListener.class) // 엔티티의 변화를 감지하여 시간을 자동 기록
public abstract class BaseTimeEntity {

    @CreatedDate    // 생성 시 자동 저장
    @Column(updatable = false)  // 생성 후에는 수정 불가하게 막음
    private LocalDateTime createdAt;

    @LastModifiedDate   // 수정 시 자동 갱신
    private LocalDateTime updatedAt;
}
```

- 이 기능을 활성화하려면 프로젝트의 메인 클래스에 반드시 @EnableJpaAuditing 어노테이션을 붙여줘야 함. 이걸 안 붙이면 시간이 null로 들어감