# 닉네임 수정

1. controller에 닉네임 수정 메서드 추가, nicknameRequest 추가

```java
public record NicknameRequest(String nickname) {}

@PatchMapping("/nickname")
public ResponseEntity<String> updateNickname(@AuthenticationPrincipal String email, @RequestBody NicknameRequest dto) {
    userService.updateNickname(email, dto.nickname());
    return ResponseEntity.ok("닉네임이 성공적으로 수정되었습니다.");
}
```

- `@AuthenticationPrincipal String email` 로 유저 정보를 받음

2. userService에 닉네임 수정 로직 추가

```java
@Transactional
public void updateNickname(String email, String newNickname) {
  User user = userRepository.findByEmail(email)
          .orElseThrow(() -> new RuntimeException("유저를 찾을 수 없습니다."));

  // 닉네임 중복 체크
  if(userRepository.existsByNickname(newNickname)) {
      throw new NicknameExistsException("이미 사용 중인 닉네임입니다.");
  }
  user.updateNickname(newNickname);
}
```

3. user 엔티티에 updateNickname 메서드 추가

```java
public void updateNickname(String newNickname) {
  if(newNickname == null || newNickname.isBlank()) {
      throw new IllegalArgumentException("닉네임은 빈값일 수 없습니다.");
  }
  this.nickname = newNickname;
}
```

# 엔티티 생성

- 클래스에 바로 @Builder를 붙일 때에는 롬복은 빌더를 만들기 위해 모든 필드를 파라미터로 갖는 생성자가 필요함
- 이때 @NoArgsConstructor(기본 생성자)를 선언하면, 롬복이 생성자를 자동으로 만들지 못해 빌더가 작동하지 않는 오류가 발생할 수 있음
  그래서 이를 방지하기 위해 **@NoArgsConstructor + @AllArgsConstructor**를 세트로 넣음

- 생성자 위에 @Builder를 붙일 때에는 이미 필요한 필드(email, password 등)로 생성자를 만들었기 때문에, 굳이 모든 필드(id 포함)를 다 때려 넣는 생성자를 따로 만들 필요가 없음

- mappedBy : **이 관계의 주인(외래 키 관리자)이 누구인가?"**를 정하는 속성
- mappedBy가 붙은 엔티티에선 조회만 가능
- `mappedBy = user`인 경우 DiaryMenmber 에 정의된 `private User user;` 여기 필드이름을 적어줌

- DiaryLike 엔티티

  - 데이터베이스 수준에서 `한 사람이 같은 일기에 좋아요를 두번 누를 수 없게` 하는 안전장치
  - @UniqueConstraint : 유일해야하는 제약 조건
    기본키와의 차이 : PK는 데이터 한 줄(Row)을 식별하는 고유 번호(id)이지만, 유니크 제약 조건은 특정 컬럼들에 담긴 값의 조합이 겹치지 않게 관리
    diary_id와 user_id를 조합해서 "A라는 사람이 1번 일기에 누른 좋아요 기록은 딱 하나만 존재해야 한다" 라는 결과가 나옴

  - if 문으로만은 중복체크가 어려움
    - 제약 조건이 없을 때 사용자가 좋아요 버튼을 두 번 광클 했을 때 거의 동시에 실행 되면서 DB에 한사람의 좋아요 데이터가 2개 쌓이는 버그가 생길 수 있음.
    - 하지만 `UniqueConstraint`를 걸어두면, DB가 마지막 순간에 저장하려 할 때 "어? 아까 들어온 거랑 똑같은 조합이네?" 하고 에러 발생

```java
@Table(
    name = "diary_like",
    uniqueConstraints = {
        @UniqueConstraint(  // 유일해야하는 제약 조건
            name = "uk_diary_user", // 제약 조건의 이름
            columnNames = {"diary_id", "user_id"} // 일기ID와 유저ID의 조합은 유일해야 함
        )
    }
)
```