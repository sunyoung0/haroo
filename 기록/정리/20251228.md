# JWT 로그인 인증 시스템
- 인증 방식 : 이메일/비밀번호 로그인 -> JWT 발급 -> 이후 요청 시 Header에 토큰 포함

1. DTO - loginRequest/Response
  - 유저로부터 받을 데이터와 응답할 데이터 정의

2. JwtService
  - 발행: 유저 정보를 subject와 claim에 담아 토큰 생성.

  - 검증: 비밀키(Signing Key)를 사용해 토큰의 유효성(만료, 위변조) 확인.

  - 추출: 토큰의 subject 칸에 저장된 이메일 정보를 꺼내오는 로직 구현.

```java
@Component
public class JwtService {
    // 24시간
    static final long EXPIRATIONTIME = 86400000;

    private static final SecretKey SIGNINGKEY = Jwts.SIG.HS256.key().build();

    public String getToken(String email, Long userId) {
        return Jwts.builder()
                .subject(email)
                .claim("userId", userId)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + EXPIRATIONTIME))
                .signWith(SIGNINGKEY)
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().verifyWith(SIGNINGKEY).build().parseSignedClaims(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public String getEmailFromToken(String token) {
        return Jwts.parser()
                .verifyWith(SIGNINGKEY)
                .build()
                .parseSignedClaims(token)
                .getPayload()
                .getSubject();
    }
}
```

3. jwtFilter - 모든 API 요청 전에 실행되는 필터
```java
@Component
@RequiredArgsConstructor
public class JwtFilter extends OncePerRequestFilter {

    private final JwtService jwtService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        // 헤더에서 Authorization 값을 가져옴
        String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION);

        // Bearer로 시작하는 토큰이 있는지 확인
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7); // Bearer 제외한 토큰만 추출

            // 토큰 검증
            if(jwtService.validateToken(token)) {
                String email = jwtService.getEmailFromToken(token);

                // 인증 객체 생성
                Authentication auth = new UsernamePasswordAuthenticationToken(email, null, Collections.emptyList());

                // 시큐리티 컨텍스트에 저장(컨트롤러가 로그인 한 유저를 알게 됨
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        }
        // 다음 필터로 넘김
        filterChain.doFilter(request, response);
    }
}
```

4. securityConfig - jwtFilter를 거친 인증된 유저만 접근 허용
```java
.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
```

5. userService - login 로직 추가
```java
@Transactional(readOnly = true)
public LoginResponse login(@Valid LoginRequest dto) {

    // 이메일로 유저 존재 확인
    User user = userRepository.findByEmail(dto.email())
            .orElseThrow(() -> new RuntimeException("이메일이 존재하지 않습니다."));

    // 비밀번호 일치 확인
    if (!passwordEncoder.matches(dto.password(), user.getPassword())) {
        throw new RuntimeException("이메일 또는 비밀번호가 일치하지 않습니다.");
    }

    // jwt 토큰 생성
    String accessToken = jwtService.getToken(user.getEmail(), user.getId());

    // 응답 DTO 생성 및 반환
    return new LoginResponse(accessToken, "Bearer", user.getEmail(), user.getId());
}
```