# tailwind

- 최신 버전은 적용이 잘 안될 수도 있음
- 그래서 tailwindcss@3 으로 @3 붙여서 버전을 다운그레이드 해줘야함.

```bash
npm install -D tailwindcss@3 postcss autoprefixer
npx tailwindcss init -p
```

- 그리고 tailwind.config.js, postcss.config.js 이 두 파일이 생성 됐는 지 확인해야함.

- tailwind.config.js 수정

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

- 마지막으로 globals.css 또는 index.css 제일 상단에 하단 3줄 추가

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

# 유효성 검사

- dto에서 유효성 검사를 하기 위해선 의존성 추가해줘야함

```gradle
implementation 'org.springframework.boot:spring-boot-starter-validation'
```

- dto 단계에서 유효성 검사를 수행하면 서비스 로직으로 잘못된 값이 들어오는 것을 차단 할 수 있음
- message 값은 그대로 에러 응답 메시지로 활용됨

- 예시

```java
@NotBlank(message = "이메일은 필수 입력 값입니다.")
@Email(message = "이메일 형식이 올바르지 않습니다.")
String email
```

- 유효성 검사를 적용 시켜둔 dto를 @RequestBody로 받는 곳에 @Valid 어노테이션을 붙여줘야함. 필수로 붙여줘야 MethodArgumentNotValidException이 작동함.
- 유효성 검사는 컨트롤러 진입 시점에서 실행됨

# 예외 처리

1. 커스텀 예외 처리

- 이메일 중복, 닉네임 중복과 같은 비즈니스 예외
- @ResponseStatus는 직접 만든 커스텀 예외 클래스에만 붙일 수 있음, 해당 예외 발생 시 자동으로 상태 코드 매핑
- 서비스는 에러를 처리하지 않고 던지기만 함

```java
@ResponseStatus(HttpStatus.CONFLICT)
public class EmailExistsException extends RuntimeException {
    public EmailExistsException(String message) {
        super(message);
    }
}

// 적용 예시
if (userRepository.existsByEmail(dto.email())) {
    throw new EmailExistsException("이미 존재하는 이메일입니다.");
}
```

2. GlobalExceptionHandler (전역 예외 처리)

- 모든 컨트롤러에서 빌생하는 예외를 감시하고 한곳에서 모아서 일관된 응답 규격(JSON)으로 변환

- 핵심 역할
  - 일관성: 모든 에러 응답 형식을 ErrorResponseRecord로 통일
  - 분리: 서비스 로직은 에러를 던지기만(throw) 하고, 처리는 핸들러가 담당
  - 디버깅: 에러 발생 시간, 상태 코드, 메시지, 발생 경로(URI)를 한눈에 파악

- @RestControllerAdvice : 이 어노테이션이 붙은 클래스는 모든 컨트롤러에서 발생하는 예외를 감시함, 예외가 발생하면 해당 클래스 내의 메소드가 호출됨

- ErrorResponseRecord를 만들어 공통 에러 양식 설정

```java
public record ErrorResponseRecord(
  LocalDateTime timestamp,
  int status,
  String error,
  String message,
  String path
) {}
```

- WebRequest :
  - request.getDescription(false)를 사용하면 에러가 발생한 API 경로(URI)를 자동으로 가져올 수 있음
  - request.getDescription(true)인 경우 client 정보가 붙어서 나옴

3. 상태 코드

- 400 Bad Request - 비즈니스 로직 위반 (이미 가입됨, 방장 탈퇴 불가 등)
- 401 UNAUTHORIZED - 로그인 - 이메일 존재 X / 이메일 or 비밀번호 틀렸을 시 예외 처리
- 403 Forbidden - 존재O, 권한이 없는 경우 (본인의 글이 아니거나 멤버가 아닌 경우)
- 404 Not Found - 다이어리/댓글/유저 등이 존재하지 않는 경우
- 409 CONFLICT - 중복 예외 처리
- 500 INTERNAL_SERVER_ERROR - 그 외 예상치 못한 모든 예외 처리 (서버 에러 500)

# JWT 로그인 인증 시스템

- 인증 방식 : 이메일/비밀번호 로그인 -> JWT 발급 -> 이후 요청 시 Header에 토큰 포함

- JwtService
  - 발행: 유저 정보를 subject와 claim에 담아 토큰 생성.

  - 검증: 비밀키(Signing Key)를 사용해 토큰의 유효성(만료, 위변조) 확인.

  - 추출: 토큰의 subject 칸에 저장된 이메일 정보를 꺼내오는 로직 구현.

- jwtFilter - 모든 API 요청 전에 실행되는 필터
- securityConfig - jwtFilter를 거친 인증된 유저만 접근 허용

# 엔티티

- 클래스에 바로 @Builder를 붙일 때에는 롬복은 빌더를 만들기 위해 모든 필드를 파라미터로 갖는 생성자가 필요함
- 이때 @NoArgsConstructor(기본 생성자)를 선언하면, 롬복이 생성자를 자동으로 만들지 못해 빌더가 작동하지 않는 오류가 발생할 수 있음
  그래서 이를 방지하기 위해 `@NoArgsConstructor + @AllArgsConstructor`를 세트로 넣음

- 생성자 위에 @Builder를 붙일 때에는 이미 필요한 필드(email, password 등)로 생성자를 만들었기 때문에, 굳이 모든 필드(id 포함)를 다 넣는 생성자를 따로 만들 필요가 없음

- mappedBy : 이 관계의 주인(외래 키 관리자)이 누구인가?를 정하는 속성
- mappedBy가 붙은 엔티티에선 조회만 가능
- ex : `mappedBy = user`인 경우 DiaryMember 에 정의된 `private User user;` 여기 필드이름을 적어줌

- DiaryLike 엔티티 ( 좋아요 기능)
  - 데이터베이스 수준에서 `한 사람이 같은 일기에 좋아요를 두번 누를 수 없게` 하는 안전장치
  - @UniqueConstraint : 유일해야하는 제약 조건
    기본키와의 차이 : PK는 데이터 한 줄(Row)을 식별하는 고유 번호(id)이지만, 유니크 제약 조건은 특정 컬럼들에 담긴 값의 조합이 겹치지 않게 관리
    diary_id와 user_id를 조합해서 "A라는 사람이 1번 일기에 누른 좋아요 기록은 딱 하나만 존재해야 한다" 라는 결과가 나옴

  - if 문으로만은 중복체크가 어려움
    - 제약 조건이 없을 때 사용자가 좋아요 버튼을 두 번 광클 했을 때 거의 동시에 실행 되면서 DB에 한사람의 좋아요 데이터가 2개 쌓이는 버그가 생길 수 있음.
    - 하지만 `UniqueConstraint`를 걸어두면, DB가 마지막 순간에 저장하려 할 때 아까 들어온 거랑 똑같은 조합이네 하고 에러 발생

```java
@Table(
    name = "diary_like",
    uniqueConstraints = {
        @UniqueConstraint(  // 유일해야하는 제약 조건
            name = "uk_diary_user", // 제약 조건의 이름
            columnNames = {"diary_id", "user_id"} // 일기ID와 유저ID의 조합은 유일해야 함
        )
    }
)
```

- JOIN FETCH: 단순히 findAllByUser를 하면 그룹 이름을 알기 위해 그룹 테이블을 계속 조회하는 N+1 문제가 발생할 수 있음. JOIN FETCH를 써서 한 번의 쿼리로 그룹 정보까지 싹 긁어오는 게 성능상 훨씬 유리

- existsByUserAndDiaryGroup_Id() 이런 식으로 적으면 @Query문을 안써도 조회 가능

- 언더바(\_)를 사용하면 명시적으로 "여기서부터는 하위 엔티티의 속성이다" 라고 구분해주는 역할

# ResponseEntity.ok().build() 를 사용하는 이유

- HTTP 응답의 상태 코드(Status Code)와 본문(Body)을 명확하고 유연하게 제어하기 위함

- ResponseEntity.ok()는 HTTP 상태 코드 200 OK를 응답으로 보내겠다는 뜻

- ResponseEntity.ok().build()는 데이터 없이 성공만 알릴 때
- 데이터를 보낼 때는 ResponseEntity.ok(data)

- 빌더 패턴 (Builder Pattern) 사용
  ResponseEntity는 객체를 생성할 때 빌더 패턴을 지원함

  .ok(): 상태 코드는 200으로 설정한다는 뜻

  .build(): 더 이상 추가할 설정(헤더나 본문 등)이 없으니 이대로 ResponseEntity 객체를 완성해서 반환한다는 뜻

# Optional 체이닝(Chaining)(함수형 스타일)

- .map(), .filter(), .flatMap(), .orElseGet() 처럼 Optional이 제공하는 메서드들을 마침표(.)로 계속 연결해서 사용하는 방식

- 체이닝 방식의 장점
  - 코드가 선언적 : if문을 써서 "어떻게(How)" 처리할지 기술하는 게 아니라, "무엇을(What)" 할지(값 있으면 삭제하고 메시지 반환해라) 기술하는 방식

  - 불필요한 변수 선언이 사라짐: Optional<DiaryLike> like = ... 처럼 중간 결과를 저장할 변수를 굳이 만들지 않아도 됨

  - Null 안정성: if(like != null) 같은 체크 없이도 Optional 내부에서 안전하게 흐름이 제어됨

  - 흐름을 따라가는 방식

# Base TimeEntity

- 단순히 필드에 LocalDateTime.now()를 넣는 것보다 좋음
  - 중복 제거 : 모든 엔티티에 생성 시간 코드를 넣을 필요 없이 상속만 받으면 끝남
  - 일관성 : 컬럼명이 통일되어 관리하기 쉬움
  - 자동화 : 수정 시간의 경우 알아서 시간을 갱신 해줌

- 시간 구현 방식,특징,추천 여부
  - LocalDateTime.now() : 직접 대입, 구현은 쉽지만, 매번 직접 코드를 짜야 하고 수정 시간 관리가 어려움
  - @PrePersist : 사용,별도 설정 없이 엔티티 내에서 해결 가능하나 중복 코드가 발생함
  - BaseTimeEntity + @CreatedDate : 가장 깔끔

```java
@Getter
@MappedSuperclass // JPA Entity 들이 이 클래스를 상속받을 경우 필드들도 컬럼으로 인식하게 함
@EntityListeners(AuditingEntityListener.class) // 엔티티의 변화를 감지하여 시간을 자동 기록
public abstract class BaseTimeEntity {

    @CreatedDate    // 생성 시 자동 저장
    @Column(updatable = false)  // 생성 후에는 수정 불가하게 막음
    private LocalDateTime createdAt;

    @LastModifiedDate   // 수정 시 자동 갱신
    private LocalDateTime updatedAt;
}
```

- 이 기능을 활성화하려면 프로젝트의 메인 클래스에 반드시 @EnableJpaAuditing 어노테이션을 붙여줘야 함. 이걸 안 붙이면 시간이 null로 들어감

## 디바운싱(Debouncing)이란?

디바운싱은 "연이어 호출되는 함수들 중 마지막(또는 처음)만 실행"하는 기술

- 그냥 15초 주기: 사용자가 미친 듯이 타자를 치고 있어도 15초마다 무조건 서버에 요청을 보냄.

- 디바운싱: 사용자가 타자를 치는 동안에는 기다렸다가, 타자를 멈추고 2초가 지나면 그때 딱 한 번 저장함.

- 프론트엔드(React, Vue 등)에서 lodash 같은 라이브러리를 쓰면 됨

# SSE(Server-Sent Events) 기반 실시간 알림 시스템

## SSE 기능을 구현하기 위해 가장 중요한 것은 SseEmitter를 관리하는 저장소와 알림을 생성하고 전송하는 서비스를 분리하는 것

- 알림 엔티티 설계 : 알림은 "누가, 무엇 때문에, 어떤 데이터를 확인해야 하는가"를 담아야 함

- SSE는 클라이언트가 서버에 한 번 연결(Handshake)을 맺으면, 서버가 일방적으로 데이터를 밀어주는 방식

- 알림 전송 프로세스
  - SSE 연결: 클라이언트가 GET /api/notifications/subscribe 요청. 서버는 SseEmitter(클라이언트와의 실시간 연결 객체) 객체를 생성해 메모리에 저장.

  - 이벤트 발생: 어떤 유저가 댓글 작성 완료.

  - 데이터 저장: Notification 엔티티를 DB에 저장 (나중에 로그인했을 때 확인용).

  - 실시간 전송: SseEmitter 저장소에서 일기 작성자의 ID를 찾아 실시간 데이터 전송.

- 구현 시 주의할 점
  - SseEmitter 만료 시간: SSE는 연결 시간이 제한되어 있음. 보통 30분~1시간 정도로 설정하며, 만료 시 클라이언트가 재연결(Reconnection)을 시도하도록 프론트엔드 처리가 필요

  - 메모리 관리: SseEmitter는 서버 메모리에 저장. 서버가 여러 대(Scale-out)라면 Redis의 Pub/Sub을 활용해야 하지만, 단일 서버 단계라면 ConcurrentHashMap을 사용해 관리하는 것으로 충분

  - 더미 데이터 전송: 연결 직후 아무 데이터도 보내지 않으면 503 에러가 발생할 수 있음. 연결 성공 시 "Event Stream Created" 같은 더미 데이터를 첫 번째로 전송하는 것이 관례.

1. EmitterRepository (연결 관리) 생성

- 먼저 서버 메모리에 클라이언트와의 연결 객체(SseEmitter)를 보관할 저장소가 필요함

2. NotificationService (비즈니스 로직)

- 알림을 DB에 저장하고, 현재 접속 중인 유저에게 실시간으로 데이터를 쏴주는 역할

3. NotificationController (엔드포인트)
   클라이언트(프론트엔드)에서 SSE를 구독하기 위한 API

4. 실제 사용 예시 (댓글 서비스 연동)
   이제 댓글이 작성될 때 알림 서비스의 send() 메서드를 호출하기만 하면 됨

- 구현 시 참고할 핵심 포인트
  Media Type: SSE 통신은 반드시 text/event-stream 타입을 사용해야 한다.

보안: 실제 서비스에서는 /subscribe 시 userId를 경로 변수로 받기보다, 시큐리티 컨텍스트(@AuthenticationPrincipal)에서 현재 로그인한 유저 정보를 가져오는 것이 안전.

트랜잭션: send() 로직에서 DB 저장은 성공했는데 SSE 전송이 실패할 경우를 대비해 예외 처리를 꼼꼼히 해주어야 함.

- EmitterRepository 와 NotificationRepository의 차이
- NotificationRepository (JPA)
  - 저장 위치 : MySQL (Disk)
  - 저장 데이터 : 알림 내역 (누가, 언제, 어떤 내용 등)
  - 생존 기간 : 영구적 (삭제 전까지)
  - 주요 용도 : 나중에 다시 보기, 읽음 처리, 히스토리 관리

- EmitterRepository (In-Memory)
  - 저장 위치 : 서버 메모리 (RAM)
  - 저장 데이터 : 클라이언트와의 실시간 연결 객체(SseEmitter)
  - 생존 기간 : 일시적 (브라우저 종료나 연결 만료 시 삭제)
  - 주요 용도 : 지금 당장 실시간으로 알림을 쏴주기 위함

- SSE와 @Transactional이 충돌이 일어날 수도 있음.

- 구독(subscribe)는 로그인이 성공하여 유효한 토큰을 발급받은 직후에 이뤄짐
  - 누구에게 알림을 보낼 지 / 권한 검증(인가) / 실시간성 보장(즉시 수신)

- 전체적인 흐름
  - 1. 로그인
  - 2. 토큰 발급
  - 3. 구독 요청 (Subscribe): 클라이언트(프론트엔드)가 받은 토큰을 헤더에 담아 GET /api/notifications/subscribe를 호출.
  - 4. 연결 유지: 서버는 SseEmitter를 생성해 메모리에 저장하고, 클라이언트는 이 연결을 계속 열어둠.
  - 5. 이벤트 수신: 다른 유저가 댓글을 달면, 서버는 메모리에서 해당 유저의 SseEmitter를 찾아 알림 발송

# Dirty Checking (더티 체킹)이란?

- Dirty Checking은 JPA 라이브러리가 제공하는 아주 편리한 기능.
- "상태 변경 검사"라는 뜻
- @Transactional 안에서 객체 값만 바꾸면 업데이트가 자동으로 됨

- 기존 방식 vs 더티체킹
  - 기존 방식: 데이터를 수정하려면 update 쿼리를 직접 작성하거나, repository.save()를 명시적으로 호출해야 함

  - 더티 체킹: 트랜잭션(@Transactional) 범위 안에서 DB에서 가져온 엔티티 객체의 값을 변경하면, 트랜잭션이 끝나는 시점에 JPA가 변경 사항을 감지해서 알아서 UPDATE 쿼리를 날려줘야함

- subscribe 메서드에 @Transactional이 걸려 있으면, unreadNotifications를 가져오는 동안 DB 커넥션을 점유하고 있게 됨. SSE는 연결을 오래 유지하는 특성이 있으므로, subscribe 메서드 자체에는 @Transactional을 붙이지 않는 것이 성능상 유리. (조회 로직이 필요하다면 별도의 readOnly = true가 걸린 서비스 메서드로 분리하는 것이 베스트)

# 스케쥴링(오래된 알림 삭제)

- @EnableScheduling 메인 클래스에 달아줘야함

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class NotificationScheduler {

    private final NotificationRepository notificationRepository;

    // 매일 새벽 3시에 실행(cron 표현식: 초 분 시 일 월 요일), 30일이 지난 '읽은 알림' 삭제
    @Scheduled(cron = "0 0 3 * * *")
    public void deleteOldNotifications() {
        // 현재 시간 기준 30일 전 계산
        LocalDateTime retentionalPeriod = LocalDateTime.now().minusDays(30);

        log.info("알림 청소 스케쥴러 가동 : 30일 지난 읽은 알림 삭제");

        notificationRepository.deleteByCreatedAtBeforeAndIsReadTrue(retentionalPeriod);
        log.info("알림 청소 완료");
    }

}
```

# Zod - 유효성 검사를 위해 가장 많이 사용되는 react 라이브러리

- if, else, regex를 직접 작성하면 코드가 길어지고 복잡해지는데, Zod를 쓰면 "데이터의 형태(Schema)"를 정의하는 것만으로 검증이 끝남.

- 장점
  - 가독성: "이메일 형식이어야 하고, 최소 8자여야 한다"는 말을 코드로 읽기 쉽게 정의

  - 재사용성: 한 번 정의한 스키마를 회원가입, 로그인 등 여러 곳에서 돌려쓸 수 있음

  - 타입 자동 생성: TypeScript 유저라면 Zod 스키마로부터 타입을 자동으로 추출할 수 있어 편리

```java
// 기존 방식
if (!emailRegex.test(value)) {
  setErrors({ email: "이메일 형식이 아닙니다." });
}
if (value.length < 8) {
  setErrors({ password: "8자 이상이어야 합니다." });
}

// zod 방식
import { z } from "zod";

const loginSchema = z.object({
  email: z.string().email("올바른 이메일 형식이 아닙니다."),
  password: z
    .string()
    .min(8, "비밀번호는 최소 8자 이상이어야 합니다.")
    .regex(/[A-Z]/, "대문자를 포함해야 합니다.") // 정규식도 체이닝 가능
});

```

# zustand 사용 상태 관리

```java
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AuthState {
  token: string | null;
  userEmail: string | null;
  nickname: string | null;
  isLoggedIn: boolean;

  // 액션들
  login: (token: string, email: string, nickname: string) => void;
  logout: () => void;
}

export const useAuthStore = create<AuthState>() (
  persist(
    (set) => ({
      token: null,
      userEmail: null,
      nickname: null,
      isLoggedIn: false,

      login: (token, email, nickname) =>
        set({
          token,
          userEmail: email,
          nickname,
          isLoggedIn: true
        }),

        logout: () => set({
          token: null,
          userEmail: null,
          nickname: null,
          isLoggedIn: false
        }),
    }),
    {
      name: 'auth-storage', // localStorage에 저장될 키 이름
    }
  )
)
```

- Zustand에 있는 값을 value에 직접 넣으면 타이핑이 되지 않을 겁니다 (읽기 전용이 됨). 수정을 하려면 useState에 초기값으로 넣어주는 방식 사용

# 플로팅 버튼

- 스크롤을 내려도 항상 같은 위치
- 부모 요소에 relative가 걸려있어야 함

# fireBase

- 구글에서 제공하는 백엔드 서비스 플랫폼(BaaS, Backend as a Service)

- 핵심 기능 (프로필 기능에 필요한 것들)
  - Authentication (인증): 이메일 로그인, 구글/카카오 로그인을 아주 쉽게 구현하게 해줌

  - Cloud Storage (저장소): 사용자들의 프로필 이미지, 영상 같은 큰 파일을 저장하는 공간

  - Firestore (데이터베이스): 사용자 이름, 상태 메시지 같은 텍스트 데이터를 저장

- 이미지 관리 흐름
  1. 이미지 선택: 사용자가 폰/PC에서 사진을 고름

  2. Storage 업로드: Firebase Storage에 이미지를 올립니다. 이때 파일 이름은 보통 users/유저아이디/profile.jpg 식으로 저장

  3. URL 추출: 업로드가 완료되면 그 사진에 접근할 수 있는 다운로드 URL을 받아옴

  4. DB 저장: 받아온 URL을 Firestore(DB)의 해당 유저 정보 항목에 저장

  5. 화면 표시: 앱을 켤 때 DB에서 URL을 읽어와서 이미지 태그(<img src="..">)에 넣어 보여줌

- 보안규칙 설정을 잘 해줘야함
  - Firebase 콘솔의 Storage > Rules 탭에서 설정

```javascript
// 테스트용(누구나 업로드 가능)
allow read, write: if true;

// 로그인 한 사용자만 본인 폴더에 접근
allow read, write: if request.auth != null;
```

- Firebase 방식: 프론트엔드 → [Firebase SDK] → Cloud Storage / Firestore (DB)
  백엔드 설정이 따로 필요하지 않음
  데이터 베이스에 이미지 URL을 저장할 공간만 있으면 됨
  필요한 곳 (User 테이블)에 imageUrl 컬럼만 추가해주면 됨

- 진행 단계

0. 결제 수단 설정 / 버킷 설정 - 프로젝트 파일들이 물리적으로 어디에 설정될 지 / 보안규칙 설정
1. firebase storage 생성
2. 프론트에 .env 파일에 환경변수 설정 및 firebaseConfig.ts 생성
3. firebaseDatabase 켜기 및 설정

- doc()함수 : 특정 문서(Document)의 주소를 만드는 것
  - Firestore는 데이터를 저장할 때 Collection(폴더) > Document(파일/문서) 라는 계층 구조를 사용. 이때 내가 수정하거나 읽고 싶은 파일이 어디에 있는지 컴퓨터에게 정확히 알려줘야 하는데, 그 경로를 설정하는 함수
